### 闭包

#### 缓存

```javascript
var mult = (function(){
  var cache = {};
  var calculate = function() { // 封闭calculate函数
    var a = 1;
    for (var i = 0, l = arguments.length; i < l; i++) {
      a = a * arguments[i];
    }
    return a;
  };
  
  return function() {
    var args = Array.prototype.join.call( arguments, ',');
    if ( args in cache ) {
      return cache[args];
    } 
    return cache[args] = calculate.apply(null, arguments);
  }
})();
```

#### 延迟局部变量的寿命

```javascript
var report = (function() {
  var imgs =[];
  return function (src) {
    var img = new Image();
    imgs.push(img);
    img.src = src;
  }
})();
```

#### 闭包和面向对象

```javascript
var extent = function() {
  var value = 0;
  return {
    call: function () {
      value++;
      console.log(value);
    }
  }
};
var extent = extent();
extent.call(); // 输出: 1
extent.call(); // 输出: 2
extent.call(); // 输出: 3
```

#### 用闭包实现命令模式

```javascript
var Tv = {
  open: function() {
    console.log('打开电视机');
  },
  close: function() {
    console.log('关闭电视机');
  }
}

var createCommand = function (receiver) {
  var execute = function() {
    return receiver.open(); // 执行命令，打开电视机
  }
  
  var undo = function() {
    return receiver.close(); // 执行命令，关闭电视
  }
  
  return {
    execute: execute,
    undo: undo
  }
};

var setCommand = function( command ) {
  document.getElemntById('execute').onClick = function() {
    command.execute(); // 输出：打开电视机
  }
  document.getElemntById('undo').onClick = function() {
    command.undo(); // 输出：关闭电视机
  }
}

setCommand( createCommand( Tv ));
```

#### 判断数据的类型

```javascript
var Type = {};

for (var i = 0, type; type = ['String', 'Array', 'Mumber'][i++];) {
  Type['is' + type] = function( obj ){
      (function( type ) {
        Type['is' + type] = function( obj ) {
          return Object.prototype.toString.call(obj) === '[object ' + type + ']';
        } 
      })(type)
    }
};

Type.isArray([]); // true
Type.isString("str"); // true
```

#### 高阶函数实现AOP

AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计功能模块。

```javascript
Function.prototype.before = function(beforefn) {
  var __self = this; // 保存原函数的引用
  return function() { // 返回包含了原函数和新函数的“代理”函数
    beforefn.apply(this, arguments); // 执行新函数，修正this
    return __self.apply(this.arguments); // 执行原函数
  }
};

Function.prototype.after = function(afterfn) {
  var __self = this;
  return function() {
    var ret = __self.apply(this, arguments);
    afterfn.apply(this, arguments);
    return ret;
  }
}

var func = function() {
  console.log(2);
}

func = func.before(function() {
  console.log(1);
}).after(function(){
  console.log(3);
});

func();
```

#### 高阶函数的其他应用

##### 1.currying

```javascript
var cost = (function() {
  var args = [];
  
  return function() {
    if (arguments.length === 0) {
      var money = 0;
      for (var i = 0, l = args.length; i < l; i++) {
        money += args[i]
      }
      return money;
    } else {
      [].push.apply(args, arguments);
    }
  }
})();

cost(100);
cost(200);
cost(300);

cost() // 600
```

curry化函数

```javascript
var currying = function(fn) {
  var args = [];
  
  return function() {
    if (arguments.length === 0) {
      return fn.apply(this, apply);
    } else {
      [].push.apply(args, arguments);
      return arguments.callee;
    }
  }
};

var cost = (function() {
  var money = 0;
  return function() {
    for (var i = 0, l = arguments.length; i < l; i++) {
      money += arguments[i];
    }
    return money;
  }
})();

var cost = curry(cost);

cost(100);
cost(200);
cost(300);

cost() // 600
```

#### 2.uncurrying

```javascript
Function.prototype.uncurrying = function() {
  var self = this;
  return function() {
    var obj = Array.prototype.shift.call(arguments);
    return self.apply(obj, arguments);
  }
}
```

例子

```javascript
for (var i = 0, fn, ary = ['push', 'shift', 'forEach']; fn = ary[i++];) {
  Array[fn] = Array.prototype[fn].uncurrying();
}

var obj = {
  "length": 3,
  "0": 1,
  "1": 2,
  "2": 3
};

Array.push(obj, 4);
console.log(obj.length);

var first = Array.shift(obj);
console.log(first);
console.log(obj);

Array.forEach(obj, function(i, n) {
  console.log(n); // 分别输出: 0, 1, 2
})
```

#### 3.函数节流

```javascript
var throttle = function(fn, interval) {
  var __self = fn, // 保存需要被延迟执行的函数引用
      timer, // 定时器
      firstTime = true; // 是否是第一次调用
  
  return function() {
    var args = arguments,
        __me = this;
    
    if (firstTime) { // 如果是第一次调用，不需延迟执行
      __self.apply(__me, args);
      return firstTime = false;
    }
    
    if ( timer ) { // 如果定时器还在，说明前一次延迟执行还没有完成
      return false;
    }
    
    timer = setTimeout(function() { // 延迟一段时间执行
      clearTimeout(timer);
      timer = null;
      __self.apply(__me, args);
    }, interval || 500);
  };
};


window.onresize = throttle(function() {
  console.log(1)
}, 500)
```

#### 4.分时函数

分批，分时执行 

```javascript
var timeChunk = function(ary, fn, count) {
  var obj, t;
  var len = ary.length;
  
  var start = function() {
    for(var i = 0; i < Math.min(count || 1, ary.length ); i++) {
      var obj = ary.shift();
      fn( obj );
    }
  };
  
  return function() {
    t = setInterval(function() {
      if (ary.length === 0) { // 如果全部节点都已经被创建好
        return clearInterval( t );
      }
      start();
    }, 200); // 分批执行的时间间隔，也可以用参数的形式传入
  };
};
```

#### 5.惰性加载函数

```javascript
var addEvent = function( elem, type, handler) {
  if ( window.addEventListener ) {
    addEvent = function(elem, type, handler) {
      elem.addEventListener(type, handler, false);
    }
  } else if ( window.attachEvent ) {
    addEvent = function( elem, type, handler) {
      elem.attachEvent('on' + type, handler)
    }
  }
  addEvent(elem, type, handler);
}

var div = documentt.getElementById('div1');

addEvent(div, 'click', function() {
  alert(1);
});

addEvemt(div, 'click', function() {
  alert(2);
});
```

## 设计模式

### 单例模式

单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

应用场景：线程池、全局缓存、浏览器中的window对象、浮窗。

```javascript
var Singleton = function (name) {
  this.name = name;
}

Singleton.instance = null;
Singleton.prototype.getName = function() {
  alert(this.name);
}

Singleton.getInstance = function(name) {
  if ( !this.instance ) {
    this.instance = new Singleton(name);
  }
  return this.instance
}

var a = Singleton.getInstance('sven1');
var b = Singleton.getInstance('sven2');

alert( a === b ); // true

// 或者
var Singleton = function(name) {
  this.name = name;
}

Singleton.prototype.getName = function() {
  alert( this.name )
}

Singleton.getInstance = (function() {
  var instance = null;
  return function( name ) {
    if ( !instance ) {
      instance = new Singleton(name);
    }
    return instance;
  }
})();

var a = Singleton.getInstance('sven1');
var b = Singleton.getInstance('sven2');

alert( a === b ); // true
```

#### 透明的单例模式

```javascript
var CreateDiv = (function () {
  var instance;
  
  var CreateDiv = function ( html ) {
    if ( instance ) {
      return instance
    }
    this.html = html
    this.init();
    return instance = this;
  };
  
  CreateDiv.prototype.init = function() {
    var div = document.createElement('div');
    div.innerHTML = this.html;
    document.body.appendChild(div);
  };
  
  return CreateDiv;
})();

var a = new CreateDiv('sven1');
var b = new CreateDiv('sven2');

alert( a === b ); // true
```

#### 用代理实现单例模式

```javascript
var CreateDiv = function( html ) {
  this.html = html;
  this.init();
}

CreateDiv.prototype.init = function() {
  var div = document.createElement('div');
  div.innerHTML = this.html;
  document.body.appendChild(div);
}

var ProxySingletonCreateDiv = (function() {
  
  var instance;
  return function( html ) {
    if ( !instance ) {
      instance = new CreateDiv(html);
    }
    return instance;
  }
})();

var a = new ProxySingletonCreateDiv( 'sven1' );
var b = new ProxySingletonCreateDiv( 'sven2' );

alert( a === b );
```

#### Javascript中的单例模式

全局变量符合这个单例模式

但是我们有必要尽量减少全局变量的使用，即使需要，也要把它的污染降到最低。

##### 1.使用命名空间

```javascript
var namespace1 = {
  a: function() {
    alert(1);
  },
  b: function() {
    alert(2);
  }
}
```

##### 动态创建命名空间

```javascript
var MyApp = {};

MyApp.namespace = function( name ) {
  var parts = name.split('.');
  var current = MyApp;
  for( var i in parts) {
    if ( !current[ parts[i] ] ) {
      current[ parts[ i ]] = {}
    }
    current = current[ parts[ i ] ];
  }
};

MyApp.namespace('event');
MyApp.namespace('dom.style');

console.dir( MyApp );

// 上述代码等价于:

var MyApp = {
  event: {},
  dom: {
    style: {}
  }
}
```

##### 2.使用闭包封装私有变量

```javascript
var user = (function() {
  var __name = 'sven',
      __age = 29;
  
  return {
    getUserInfo: function() {
      return __name + '-' + __age
    }
  }
})
```

#### 惰性单例

instance实例对象总是在我们调用Singleton.getInstance的时候才被创建，而不是在页面加载好的时候就创建。

```javascript
Singleton.getInstance = (function() {
  var instance = null;
  return function( name ) {
    if ( !instance ) {
      instance = new Singleton( name );
    }
    return instance;
  }
})
```

#### 通用的惰性单例

```javascript
var createIframe = (function() {
  var iframe;
  return function() {
    if (!iframe) {
      iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
    }
    return iframe;
  }
})
```

抽离

```javascript
var getSingle = function(fn) {
  var result;
  return function() {
    return result || (result = fn.apply(this, arguments));
  }
}
```

例子

```javascript
var createLoginLayer = function () {
  var div = document.createElement('div');
  div.innerHTML = '我是登录浮窗';
  div.style.display = 'none';
  document.body.appendChild(div);
}

var createSingleLoginLayer = getSingle(createLoginLayer);

document.getElementById('loginBtn').onClick = function() {
  var loginLayer = createSingleLoginLayer();
  loginLayer.style.display = 'block';
}
```

### 策略模式

策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以互相替换。

一个基于策略模式的程序至少由两部分组成。第一个部分是一组策略类，策略类封装了具体的算法，并负责具体的计算过程。第二个部分是环境类Context，Context接受客户的请求，随后把请求委托给某一个策略类。

```javascript
var performanceS  = function(){};

performanceS.prototype.calculate = function( salary ) {
  return salary * 4;
}

var performanceA = function(){};

performanceA.prototype.calculate = function( salary ) {
  return salary * 3;
}

var performanceB = function(){};

performanceB.prototype.calculate = function( salary ) {
  return salary * 2;
}

var Bonus = function() {
  this.salary = null;
  this.strategy = null;
};

Bouns.prototype.setSalary = function( salary ) {
  this.salary = salary; 
}

Bouns.prototype.setStrategy = function( strategy ) {
  this.strategy = strategy;
}

Bouns.prototype.getBouns = function() {
  if (!this.strategy) {
    throw new Error('未设置strategy属性');
  }
  return this.strategy.calculate(this.salary);
}

var bouns = new Bouns();

bouns.setSalary( 10000 );
bouns.setStrategy( new performanceS() );

console.log(bouns.getBouns()); // 40000

bouns.setStrategy( new performanceA() );
console.log(bouns.getBouns()); // 30000
```

javascript版本的策略模式

```javascript
var strategies = {
  "S": function( salary ) {
    return salary * 4;
  },
  "A": function( salary ) {
    return salary * 3;
  },
  "B": function( salary ) {
    return salary * 2;
  }
}

var calculateBouns = function( level, salary ){
  return strategies[ level ]( salary );
}

console.log( calculateBouns('S', 20000)); // 80000
console.log( calculateBouns('A', 10000)); // 30000
```

策略模式---动画应用

```javascript
var tween = {
  linear: function( t, b, c, d) {
    return c*t/d + b;
  },
  easeIn: function( t, b, c, d) {
    return c * ( t /= d) * t + b;
  },
  strongEaseIn: function( t, b, c, d) {
    return c * ( t /= d) * t * t * t * t + b;
  },
  strongEaseOut: function( t, b, c, d) {
    return c * (( t = t / d - 1) * t * t * t * t + 1) + b;
  },
  sineaseIn: function( t, b, c, d) {
    return c * ( t / = d) * t * t + b;
  },
  sineaseOut: function( t, b, c, d) {
    return c * (( t = t / d - 1) * t * t + 1) + b;
  }
}
```

```html
<body>
  <div style="position: absolute; background:blue" id="div">
    我是div
  </div>
</body>
```

```javascript
var Animate = function(dom) {
  this.dom = dom;
  this.startTime = 0;
  this.startPos = 0;
  this.endPos = 0;
  this.propertyName = null;
  this.easing = null;
  this.duration = null;
}

Animate.prototype.start = function(propertyName, endPos, duration, easing) {
  this.startTime = +new Date;
  this.stratPos = this.dom.getBoundingClientRect()[propertyName];
  this.propertyName = propertyName;
  this.endPos = endPos;
  this.duration = duration;
  this.easing = tween[ easing ];
  
  var self = this;
  var timeId = setInterval(function() {
    if ( self.step() === false) {
      clearInterval(timeId);
    }
  }, 19)
}

Animate.prototype.step = function() {
  var t = +new Date;
  if ( t >= this.startTime + this.duration ) {
    this.update( this.endPos );
    return false;
  }
  var pos = this.easing( t - this.startTime, this.startPos, this.endPos - this.startPos, this.duration );
  this.update(pos);
}

Animate.prototype.update = function(pos) {
  this.dom.style[ this.propertyName] = pos + 'px'
}

var div = document.getElementById('div');
var animate = new Animate(div);

animate.start('left', 500, 1000,, 'strongEaseOut')
```

用策略模式重构表单校验

```javascript
var strategies = {
  isNonEmpty: function(value, errorMsg) { // 不为空
    if (value === '') {
      return errorMsg;
    }
  },
  minLength: function(value, length, errorMsg) { // 限制最小长度
    if (value.length < length) {
      return errorMsg;
    }
  },
  isMobile: function(value, errorMsg) { // 手机号码格式
    if (!/(^1[3|5|8][0-9]{9}$)/.test(value)) {
      return errorMsg;
    }
  }
};

var Validator = function() {
  this.cache = []; // 保存校验规则
}

Validator.prototype.add = function( dom, rule, errorMsg) {
  var ary = rule.split(':'); // 把strategy和参数分开
  this.cache.push(function() { // 把校验的步骤用空函数包装起来，并且放入cache
    var strategy = ary.shift(); // 用户挑选的strategy
    ary.unshift( dom.value ); // 把input的value添加进参数列表
    ary.push( errorMsg ); // 把errorMsg添加进参数列表
    return startegies[strategy].apply(dom, ary);
  });
};

Validator.prototype.start = function() {
  for (var i = 0, validatorFunc; validatorFunc = this.cache[ i++ ];) {
    var msg = validatorFunc(); // 开始校验，并取得校验后的返回信息
    if (msg) { // 如果有确切的返回值，说明校验没有通过
      return msg
    }
  }
}

var vlidataFunc = function() {
  var validator = new Validator(); // 创建一个 validator 对象
  
  /***************添加一些校验规则**************/
  validator.add( registerForm.userName, 'isNonEmpty', '用户名不能为空');
  validator.add( registerForm.password, 'minLength: 6', '密码长度不能少于6位');
  validator.add( registerForm.phoneNumber. 'isMobile', '手机号码格式不正确');
  
  var errorMsg = validator.start(); // 获得校验结果
  return  errorMsg; // 返回校验结果
}

var registerForm = document.getElementById('registerForm');
registerForm.onsubmit = function() {
  var errorMsg = validataFunc();
  if ( errorMsg ) {
    alert( errorMsg );
    return false; // 阻止表单提交
  }
}
```

#### 策略模式的优缺点

优点：

1.策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。

2.策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它们易于切换，易于理解，易于扩展。

3.策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的肤质粘贴工作。

4.在策略模式中利用组合和委托来让Context拥有执行算法的能力，这也是继承的一种更轻便的替代方案

缺点：

1.使用策略模式回在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。

2.要使用策略模式必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。

